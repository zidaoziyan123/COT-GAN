import tensorflow as tf
from tensorflow.keras import regularizers
import tensorflow.keras.layers as layers
import tensorflow_probability as tfp
import tensorflow_hub as hub
tf.keras.backend.set_floatx('float32')


class SimpleGenerator(tf.keras.Model):
    '''
    Generator for creating fake time series data (y_1, y_2,...,y_T) from the latent variable Z.
    Args:
         inputs: (numpy array) latent variables as inputs to the RNN model has shape
                 [batch_size, time_step, z_hidden_dims]
    Returns:
          output of RNN generator
    '''
    def __init__(self, batch_size, seq_len, time_steps, sub_seq_len, dx, state_size, z_dims, training_scheme,
                 rnn_activation='sigmoid', output_activation='linear'):
        super(SimpleGenerator, self).__init__()

        self.batch_size = batch_size
        self.seq_len = seq_len
        self.time_steps = time_steps
        self.sub_seq_len = sub_seq_len
        self.dx = dx
        dense_layer_unit = max(10, self.sub_seq_len*2)
        self.state_size = state_size
        self.z_dims = z_dims
        self.training_scheme = training_scheme

        self.rnn_activation = rnn_activation
        self.output_activation = output_activation
        self.l2_regularisation = None
        self.counter = 1
        # last lstm output as the input to dense layer
        self.dense_layer = tf.keras.layers.Dense(units=self.state_size, activation='relu', use_bias=True)
        self.dense_layer2 = tf.keras.layers.Dense(units=self.state_size, activation='relu', use_bias=True)
        self.output_layer = tf.keras.layers.Dense(units=self.seq_len, activation=self.output_activation,
                                                  use_bias=True)

    def call(self, inputs, training=True, mask=None):
        y = self.dense_layer(inputs)
        y = self.dense_layer2(y)
        y = self.output_layer(y)
        y = tf.reshape(tensor=y, shape=[self.batch_size, self.seq_len//self.dx, self.dx])
        return y


class IdentityDiscriminator(tf.keras.Model):
    def __init__(self, *args, **kwargs):
        super(IdentityDiscriminator, self).__init__()    
    
    def call(self, inputs, training=None, mask=None):
        return inputs


class RandomLinearDiscriminator(tf.keras.Model):
    def __init__(self, *args, **kwargs):
        super(RandomLinearDiscriminator, self).__init__()    
        kwargs["use_bias"] = False
        self.proj = tf.keras.layers.Dense(*args, **kwargs)
        self.W = None
        self.std = None

    def update(self):
        if self.W is None:
            self.W = self.proj.weights[0]
            self.std = tf.math.reduce_std(self.W)
        self.W.assign(tf.random.normal(self.W.shape) * self.std)
    
    def call(self, x, **kwargs):
        x = tf.reshape(x, [x.shape[0], -1])
        return self.proj(x, **kwargs)


class BenchmarkDiscriminator(tf.keras.Model):
    def __init__(self, batch_size, seq_len, hidden_size, regularisation=None, model_size=1, output_activation='linear'):
        super(BenchmarkDiscriminator, self).__init__()

        self.batch_size = batch_size
        self.seq_len = seq_len
        self.regularisation = regularisation
        self.model_size = model_size
        self.hidden_size = hidden_size
        self.output_activation = output_activation

        self.encoder1 = tf.keras.layers.Dense(units=self.hidden_size*self.model_size, activation='relu', use_bias=True)

        self.encoder2 = tf.keras.layers.Dense(units=self.hidden_size*self.model_size,
                                              activation=self.output_activation, use_bias=True)

    def call(self, inputs, training=None, mask=None):
        inputs = tf.reshape(inputs, [self.batch_size, self.seq_len])
        h1 = self.encoder1(inputs)
        out = self.encoder2(h1)
        return out


class CausalDiscriminator(tf.keras.Model):
    '''
    Generator for creating fake time series data (y_1, y_2,...,y_T) from the latent variable Z.
    Args:
         inputs: (numpy array) latent variables as inputs to the RNN model has shape
                 [batch_size, time_step, sub_sequence_hidden_dims]
    Returns:
          output of RNN generator
    '''

    def __init__(self, batch_size, seq_len, time_steps, sub_seq_len, state_size,
                 rnn_activation='sigmoid', output_activation='tanh'):
        super(CausalDiscriminator, self).__init__()

        self.batch_size = batch_size
        self.seq_len = seq_len
        self.time_steps = time_steps
        self.sub_seq_len = sub_seq_len
        self.state_size = state_size

        self.rnn_activation = rnn_activation
        self.output_activation = output_activation
        self.l2_regularisation = None

        self.lstm_layer1 = tf.keras.layers.LSTM(self.state_size, activation=self.output_activation,
                                                recurrent_activation=self.rnn_activation, use_bias=True,
                                                kernel_regularizer=regularizers.l2(self.l2_regularisation),
                                                bias_regularizer=regularizers.l2(self.l2_regularisation),
                                                return_sequences=True)

        self.bn1 = tf.keras.layers.BatchNormalization()

        self.lstm_layer2 = tf.keras.layers.LSTM(self.state_size, activation=self.output_activation,
                                                recurrent_activation=self.rnn_activation, use_bias=True,
                                                kernel_regularizer=regularizers.l2(self.l2_regularisation),
                                                bias_regularizer=regularizers.l2(self.l2_regularisation),
                                                return_sequences=False)
        self.bn2 = tf.keras.layers.BatchNormalization()

        self.dense_layer = tf.keras.layers.Dense(units=self.state_size, activation=self.output_activation, use_bias=True)

        self.bn3 = tf.keras.layers.BatchNormalization()

        self.output_layer = tf.keras.layers.Dense(units=self.state_size, activation=self.output_activation, use_bias=True)

    def call(self, inputs, training=True, mask=None):
        inputs = tf.reshape(tensor=inputs, shape=[self.batch_size, self.time_steps, self.sub_seq_len])
        lstm_h1 = self.lstm_layer1(inputs)
        outputs = tf.reshape(tensor=lstm_h1, shape=[self.batch_size, -1])
        return outputs


class RNNDiscriminator(tf.keras.Model):
    '''
    Discriminator for H or M
    Args:
         inputs: (numpy array) real time series data (x_1, x_2,...,x_T) and fake samples (y_1, y_2,...,y_T) as inputs
         to the RNN model has shape [batch_size, time_step, x_dims]
    Returns:
          output of RNN generator
    '''
    def __init__(self, batch_size, seq_len, time_steps, sub_seq_len, state_size,
                 rnn_activation='sigmoid', output_activation='tanh'):
        super(RNNDiscriminator, self).__init__()

        self.batch_size = batch_size
        self.seq_len = seq_len
        self.time_steps = time_steps
        # sequence length per time step
        self.sub_seq_len = sub_seq_len
        self.state_size = state_size

        self.rnn_activation = rnn_activation
        self.output_activation = output_activation
        self.l2_regularisation = None

        self.lstm_layer1 = tf.keras.layers.LSTM(self.state_size, activation=self.output_activation,
                                                recurrent_activation=self.rnn_activation, use_bias=True,
                                                kernel_regularizer=regularizers.l2(self.l2_regularisation),
                                                bias_regularizer=regularizers.l2(self.l2_regularisation),
                                                return_sequences=False)

        self.bn1 = tf.keras.layers.BatchNormalization()

        self.lstm_layer2 = tf.keras.layers.LSTM(self.state_size, activation=self.output_activation,
                                                recurrent_activation=self.rnn_activation, use_bias=True,
                                                kernel_regularizer=regularizers.l2(self.l2_regularisation),
                                                bias_regularizer=regularizers.l2(self.l2_regularisation),
                                                return_sequences=False)
        self.bn2 = tf.keras.layers.BatchNormalization()

        self.dense_layer = tf.keras.layers.Dense(units=self.state_size, activation=self.output_activation, use_bias=True)

        self.bn3 = tf.keras.layers.BatchNormalization()

        self.output_layer = tf.keras.layers.Dense(units=self.state_size, activation=self.output_activation, use_bias=True)

    def call(self, inputs, training=True, mask=None):
        inputs = tf.reshape(tensor=inputs, shape=[self.batch_size, self.time_steps, self.sub_seq_len])
        lstm_h1 = self.lstm_layer1(inputs)
        inputs = inputs[:, ::-1, :]
        lstm_h2 = self.lstm_layer2(inputs)
        outputs = tf.keras.layers.concatenate([lstm_h1, lstm_h2])
        outputs = self.output_layer(outputs)
        outputs = tf.reshape(tensor=outputs, shape=[self.batch_size, -1])
        return outputs


class ToyGenerator(tf.keras.Model):
    '''
    Generator that combines RNN with FC for creating fake time series data (y_1, y_2,...,y_T)
    from the latent variable Z.
    Args:
        inputs: (numpy array) latent variables as inputs to the RNN model has shape
                [batch_size, time_step, sub_sequence_hidden_dims]
    Returns:
        output of generator
    '''
    def __init__(self, batch_size, time_steps, Dz, Dx, state_size, filter_size, output_activation='sigmoid', bn=False,
                 nlstm=1, nlayer=2, Dy=0, rnn_bn=False):
        super().__init__()

        self.Dz = Dz
        self.Dy = Dy
        self.Dx = Dx
        self.batch_size = batch_size
        self.state_size = state_size
        self.time_steps = time_steps
        self.rnn = tf.keras.Sequential()
        k_init = None
        self.rnn.add(layers.LSTM(self.state_size, return_sequences=True, recurrent_initializer=k_init, kernel_initializer=k_init))
        if rnn_bn:
            self.rnn.add(tf.keras.layers.BatchNormalization())

        for i in range(nlstm-1):
            self.rnn.add(layers.LSTM(self.state_size, return_sequences=True, recurrent_initializer=k_init, kernel_initializer=k_init))
            if rnn_bn:
                self.rnn.add(tf.keras.layers.BatchNormalization())

        self.fc = tf.keras.Sequential()
        for i in range(nlayer-1):
            self.fc.add(layers.Dense(units=filter_size, activation=None, use_bias=True))
            if bn:
                self.fc.add(tf.keras.layers.BatchNormalization())
            self.fc.add(layers.ReLU())
        self.fc.add(layers.Dense(units=Dx, activation=output_activation, use_bias=True))

    def call(self, inputs, y=None, training=True, mask=None):

        z = tf.reshape(tensor=inputs, shape=[self.batch_size, self.time_steps, self.Dz])
        if y is not None:
            y = tf.broadcast_to(y[:, None, :], [self.batch_size, self.time_steps, self.Dy])
            z = tf.concat([z, y], -1)

        lstm = self.rnn(z, training=training)

        x = self.fc(lstm, training=training)
        x = tf.reshape(tensor=x, shape=[self.batch_size, self.time_steps, self.Dx])
        return x


class ToyDiscriminator(tf.keras.Model):
    '''
    1D CNN Discriminator for H or M
    Args:
        inputs: (numpy array) real time series data (x_1, x_2,...,x_T) and fake samples (y_1, y_2,...,y_T) as inputs
        to the RNN model has shape [batch_size, time_step, x_dims]
    Returns:
        outputs: h or M of shape [batch_size, time_step, J]
    '''

    def __init__(self, batch_size, time_steps, Dz, Dx, state_size, filter_size, bn=False, kernel_size=5, strides=1,
                 output_activation="tanh", nlayer=2, nlstm=0):
        super().__init__()

        self.batch_size = batch_size
        self.state_size = state_size
        self.time_steps = time_steps
        self.Dz = Dz
        self.Dx = Dx

        self.fc = tf.keras.Sequential()
        self.fc.add(tf.keras.layers.Conv1D(filters=filter_size, kernel_size=kernel_size,
                                           padding="causal", strides=strides))

        for i in range(nlayer-1):
            if bn:
                self.fc.add(tf.keras.layers.BatchNormalization())
            self.fc.add(layers.ReLU())
            self.fc.add(tf.keras.layers.Conv1D(filters=state_size, kernel_size=kernel_size,
                                               activation=output_activation if i == nlayer-2 else None,
                                               padding="causal", strides=strides))
        for i in range(nlstm):
            if bn:
                self.fc.add(tf.keras.layers.BatchNormalization())
            self.fc.add(layers.LSTM(state_size, return_sequences=True))

    def call(self, inputs, training=True, mask=None):

        x = tf.reshape(tensor=inputs, shape=[self.batch_size, self.time_steps, self.Dx])
        z = self.fc(x)
        return z


class VideoDCG(tf.keras.Model):
    '''
    Generator for creating fake video sequence (y_1, y_2,...,y_T) from the latent variable Z.
    Args:
         inputs: (numpy array) latent variables as inputs to the RNN layers has shape
                 [batch_size, time_step, z_weight*z_height]
    Returns:
          output of generator: fake video sequence (y_1, y_2,...,y_T)
          of shape [batch_size, x_height, x_weight*time_step, channel]
    '''
    def __init__(self, batch_size, time_steps, x_width, x_height, z_width, z_height, state_size,
                 filter_size=64, bn=False, output_activation="sigmoid", nlstm=1, cat=False, nchannel=3):
        super(VideoDCG, self).__init__()
        self.batch_size = batch_size
        self.time_steps = time_steps
        self.x_width = x_width
        self.x_height = x_height
        self.state_size = state_size
        self.z_width = z_width
        self.z_height = z_height
        self.filter_size = filter_size
        self.nlstm = nlstm
        self.cat = cat
        self.nchannel = nchannel

        # last lstm output as the input to dense layer
        self.last_lstm_h = None
        self.bn = bn

        self.lstm_layer1 = tf.keras.layers.LSTM(self.state_size, return_sequences=True)
        if self.bn:
            self.bn1 = tf.keras.layers.BatchNormalization()

        self.lstm_layer2 = tf.keras.layers.LSTM(self.state_size*2, return_sequences=True)

        if self.bn:
            self.bn2 = tf.keras.layers.BatchNormalization()
        
        model = tf.keras.Sequential()
        model.add(layers.Dense(8*8*self.filter_size*4, use_bias=False))
        if self.bn:
            model.add(layers.BatchNormalization())
        model.add(layers.LeakyReLU())

        model.add(layers.Reshape((8, 8, self.filter_size*4)))
        # assert model.output_shape == (None, 8, 8, 256) # Note: None is the batch size

        model.add(layers.Conv2DTranspose(self.filter_size * 4, (5, 5), strides=(1, 1), padding='same', use_bias=False))
        # assert model.output_shape == (None, 16, 16, 128)
        if self.bn:
            model.add(layers.BatchNormalization())
        model.add(layers.LeakyReLU())

        model.add(layers.Conv2DTranspose(self.filter_size*2, (5, 5), strides=(2, 2), padding='same', use_bias=False))
        # assert model.output_shape == (None, 16, 16, 128)
        if self.bn:
            model.add(layers.BatchNormalization())
        model.add(layers.LeakyReLU())

        if self.x_width == 64:
            model.add(layers.Conv2DTranspose(self.filter_size, (5, 5), strides=(2, 2), padding='same', use_bias=False))
            # assert model.output_shape == (None, 32, 32, 64)
            if self.bn:
                model.add(layers.BatchNormalization())
            model.add(layers.LeakyReLU())

        model.add(layers.Conv2DTranspose(self.nchannel, (5, 5), strides=(2, 2), padding='same', use_bias=False,
                                         activation=output_activation))

        self.deconv = model

    def call_all(self, inputs_z, inputs_y, training=True, mask=None):
        # for RNN, z has shape of [batch_size, time_step, sub_sequence_hidden_dims]
        z = tf.reshape(tensor=inputs_z, shape=[self.batch_size, self.time_steps, self.z_width*self.z_height])
        y = tf.broadcast_to(inputs_y[:, None, :], [self.batch_size, self.time_steps, inputs_y.shape[-1]])
        zy = tf.concat([z, y], -1)

        lstm_h = self.lstm_layer1(zy)
        if self.cat:
            lstm_h = tf.concat([lstm_h, y], -1)

        if self.bn:
            lstm_h = self.bn1(lstm_h)

        lstm_h = self.lstm_layer2(lstm_h)
        if self.bn:
            lstm_h = self.bn2(lstm_h)

        # input shape for conv3D: (batch, depth, rows, cols, channels)
        conv_inputs = tf.reshape(lstm_h, [self.batch_size * self.time_steps, -1])
        y = self.deconv(conv_inputs)
        
        y = tf.reshape(y, [self.batch_size, self.time_steps, self.x_height, self.x_width, self.nchannel])
        y = tf.transpose(y, (0, 2, 1, 3, 4))
        y = tf.reshape(tensor=y, shape=[self.batch_size, self.x_height, self.x_width*self.time_steps, self.nchannel])
        return zy, lstm_h, y

    def call(self, *args, **kwargs):
        return self.call_all(*args, **kwargs)[-1]


class VideoDCD(tf.keras.Model):
    '''
    Discriminator for H or M
    Args:
        inputs: (numpy array) real time series data (x_1, x_2,...,x_T) and fake samples (y_1, y_2,...,y_T) as inputs
        to the model has shape [batch_size, x_height, x_weight*time_step, channel]
    Returns:
        outputs: h or M of shape [batch_size, time_step, J]
    '''

    def __init__(self, batch_size, time_steps, x_width, x_height, z_width, z_height, state_size,
                 filter_size=64, bn=False, nchannel=3):
        super(VideoDCD, self).__init__()

        self.batch_size = batch_size
        self.time_steps = time_steps
        self.x_width = x_width
        self.x_height = x_height
        self.state_size = state_size
        self.z_width = z_width
        self.z_height = z_height
        self.filter_size = filter_size
        self.bn = bn
        self.nchannel = nchannel

        model = tf.keras.Sequential()
        model.add(layers.Conv2D(self.filter_size, (5, 5), strides=(2, 2), padding='same',
                                input_shape=[x_width, x_height, nchannel]))
        if self.bn:
            model.add(layers.BatchNormalization())
        model.add(layers.LeakyReLU())

        model.add(layers.Conv2D(self.filter_size*2, (5, 5), strides=(2, 2), padding='same'))
        if self.bn:
            model.add(layers.BatchNormalization())
        model.add(layers.LeakyReLU())

        if x_width == 64:
            model.add(layers.Conv2D(self.filter_size*4, (5, 5), strides=(2, 2), padding='same'))
            if self.bn:
                model.add(layers.BatchNormalization())
            model.add(layers.LeakyReLU())

        self.conv = model
        
        self.rnn = tf.keras.Sequential()
        if x_width == 64:
            self.rnn.add(tf.keras.layers.LSTM(self.filter_size*4, return_sequences=True))
        elif x_width == 32:
            self.rnn.add(tf.keras.layers.LSTM(self.filter_size*2, return_sequences=True))

        if self.bn:
            self.rnn.add(tf.keras.layers.BatchNormalization())
        self.rnn.add(tf.keras.layers.LSTM(self.state_size, return_sequences=True))

    def call(self, inputs, training=True, mask=None):
        # permute original data shape [batch_size, h, timesteps, w, channels]
        # to [batch_size, timesteps, h, w, channels] as convnet inputs
        z = tf.reshape(tensor=inputs, shape=[self.batch_size, self.x_height, self.time_steps,
                                             self.x_width, self.nchannel])
        z = tf.transpose(z, (0, 2, 1, 3, 4))
        z = tf.reshape(tensor=z, shape=[self.batch_size * self.time_steps, self.x_height, self.x_width, self.nchannel])

        z = self.conv(z)
        z = tf.reshape(z, shape=[self.batch_size, self.time_steps, -1])
        z = self.rnn(z)

        return z


class RandomLinearProjector(tf.keras.Model):
    '''
    Random linear projector for dimension reduction for real and fake time series data
    Args:
        inputs: (numpy array) real time series data (x_1, x_2,...,x_T) and fake samples (y_1, y_2,...,y_T) that
        has shape [batch_size, time_step, x_dims]
    Returns:
        outputs: projection of shape [batch_size, filter size]
    '''
    def __init__(self, *args, **kwargs):
        super(RandomLinearProjector, self).__init__()    
        kwargs["use_bias"] = False
        self.proj = tf.keras.layers.Dense(*args, **kwargs)
        self.W = None
        self.std = None

    def update(self):
        if self.W is None:
            self.W = self.proj.weights[0]
            self.std = tf.math.reduce_std(self.W)
        self.W.assign(tf.random.normal(self.W.shape) * self.std)
    
    def call(self, x, **kwargs):
        x = tf.reshape(x, [x.shape[0], -1])
        x = self.proj(x, **kwargs)
        x = x[..., None]
        return x


class VideoLinearProjector(tf.keras.Model):
    '''
    Random linear projector for dimension reduction for real and fake video data
    Args:
        inputs: (numpy array) real time series data (x_1, x_2,...,x_T) and fake samples (y_1, y_2,...,y_T) that
         has shape [batch_size, x_height, x_weight*time_step, channel]
    Returns:
        outputs: projection of shape [batch_size, time_step, filter size]
    '''
    def __init__(self, batch_size, time_steps, x_width, x_height, channels=3, filter_size=64):
        super().__init__()    
        self.batch_size = batch_size
        self.time_steps = time_steps
        self.x_width = x_width
        self.x_height = x_height
        self.proj = tf.keras.layers.Dense(filter_size, use_bias=False)
        self.channels = channels
        self.W = None
        self.std = None

    def update(self):
        if self.W is None:
            self.W = self.proj.weights[0]
            self.std = tf.math.reduce_std(self.W)
        self.W.assign(tf.random.normal(self.W.shape) * self.std)
    
    def call(self, x, **kwargs):
        x = tf.reshape(tensor=x, shape=[self.batch_size, self.x_height, self.time_steps, self.x_width, self.channels])
        x = tf.transpose(x, (0, 2, 1, 3, 4))
        x = tf.reshape(x, [x.shape[0], x.shape[1], -1])
        x = self.proj(x, **kwargs)
        return x
